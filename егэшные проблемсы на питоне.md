# Здесь и далее в документе будут рассмотрены всевозможные решения задач ЕГЭ на python'e

## Задачи 5, 8, 9, 12, 13, 14, 16, 17, 23, 24, 25, 26, 27

## 5
Задача рассчитана на перевод в двоичную систему счисления и работу с ней.

	Функция перевода **числа** из десятичной системы в двоичную с образованием **строки**:
~~~python
a = bin(n)[2:]
~~~
Далее идут более-менее стандартные функции python'а, в зависимости от условий задачи (например, сравнения, четность-нечетность, etc.)
Также стоит упомянуть работу со строками. Для примера: 
`если число N четное, то к его двоичной записи слева приписывается 1, а справа 10. Если число N нечетное, то к его двоичной записи справа приписывается 01.`
```python
if n % 2 == 0:
	a = '1' + a + '10'
else:
	a = a + '01'
```
Вуаля! Теперь ищем то, что задано нам задачей и наслаждаемся правильным ответом.


## 8
Задача настраивает нас на работу со вложенными циклами, но есть другой способ: библиотека **itertools**. Сама библиотека обширная, но нам понадобится один интересный метод в циклах.
Пример задачи:
	`Петя составляет из букв слова ЛИСТОК 4-буквенные слова. Найдите количество слов, начинающихся на К и имеющих ровно 2 гласные буквы.`
Порядок букв нам не важен, т.к. мы ищем число, поэтому можно оставить неизменным. Начинаем писать с библиотеки:
```python
from itertools import *

abc = 'ЛИСТОК' # заводим алфавит для наших слов
x = 0 # переменная-счетчик
for i in product(abc,repeat=4) # все слова в этом наборе из 4 букв у нас
	if i[0]=='К': # первая буква - К
		if i.count('И')+i.count('О')==2: # сумма всех гласных - 2
			x+=1
print(x)
```
Запомните, что цикл, использующийся в этой задаче, в переменной i дает нам не **строку**, а **массив символов** (так что по желанию можно оформить ''.join(i) в цикл, и у нас теперь будет строка).
*abc* в скобках цикла заставляет массив заполняться символами из *abc* по **порядку, записанному в переменной**, так что первая буква нашего алфавита - *Л*.
Также при подключении библиотеки символ * обозначает, что мы подключаем **всю** библиотеку, а не определенные функции из нее.


### 9
Знаю, что многие предпочтут решить задачу в экселе, но на питоне решение красивее и, скорее всего, быстрее.
Для начала нам понадобится сделать файл перевариваемым для питона - открываем файл в экселе, жмем "Сохранить как", находим свою папку с пайтоновским проектом и сохраняем файл туда **в формате .txt или .csv(разделители - запятые)**. Это определяет разделители текста и его метод переноса, например, в формате .csv разделителями будут являться **точки с запятой(или запятые, тоже проверьте)**, а методом переноса - **\n**.
Выглядит же голая строка в формате .csv так:
*4;3452;25;234\n*
Для работы с числами нам будет необходимо убрать разделители и символ переноса.
Кстати, далее будет код для .csv, поэтому рекомендую самим проверить символы разделения и переноса для .txt - слева от области кода в пайчарме можно увидеть ваши файлы в папке, а оттуда они тащатся на область справа от вашего main.py(файла, из которого пайчарм готов хавать программу)
```python
s = open('название файла.расширение файла')
x = 0 # переменная-счетчик, в большинстве задач нужно
# но могут попасться задачи типа "найдите максимальную сумму", поэтому можно завести сюда пустой массив b = [] и в него методом b.append(ваше_значение) вводить все суммы, а потом вывести max(b)
for f in s: # начинаем считывать файл
	f = f.replace('\n','') # убираем символ переноса
	f.split(';') # разделяем одну строку 
	j = [int(i) for i in f] # заполняем новый массив уже реальными числами
	... # условия вашей задачи
```
Кстати, в строке 5 был использован более простой для понимания метод заполнения массива; но это все равно будет считаться циклом, просто в упрощенном виде(для тех, кому очень важно время выполнения программы).
Теперь к примеру задачи:
`В строке 4 значения, определить, значения в каких строках могут быть сторонами прямоугольника.`
```python
...
j = [int(i) for i in f]
j.sort() # самая банальная сортировка от меньшего к большему
# эту задачку можно решать разными способами, сделаете другой - вам же лучше
for i in range(len(j)): # range(len(j)), чтобы можно было юзать индексы переменных
	if i[0]==i[1] and i[2]==i[3]:
		x+=1
print(x)
```
Все?... думаю, да.


### 12
Одна из самых легких задачек на работу со строками. В ней обязателен метод *.replace*
Для начала - списываем весь код из задачи вам в питон(я верю, это легко). 
Затем смотрим, какая строка нам дана. В примере - строка а состоит из 69 цифр "2".
```python
a = '2'*69 # заводим строку
while '2222' in a or '55' in a: # это типа мы списали код из задачи
	if '2222' in a: # значения придуманы с ходу, прога зациклится скорее всего
		a = a.replace('2222','52',1) # применяем наш метод replace
	else:
		a = a.replace('55','25',1)
print(a)
```
Метод replace заменяет первый аргумент в строке на второй.
Примечание: метод replace, описанный мной выше в 9 задаче, имел всего 2 аргумента, здесь же их 3. Разница? В этой задаче метод используется всего 1 раз за итерацию цикла, поэтому и третий аргумент - 1. В 9 задаче нам нужно избавиться от всех '\n' , а пустой аргумент в replace заменяет все найденные элементы единовременно.


### 13
ХАХАХА, вы думали, я буду решать эту задачку ручками? Неа, в питоне даже для такой задачи есть библиотека. Называется она просто: **ipaddress**.
`В терминологии сетей TCP/IP маской сети называют двоичное число, которое показывает, какая часть IP⁠-⁠адреса узла сети относится к адресу сети, а какая  — к адресу узла в этой сети. Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и маске сети. Сеть задана IP⁠-⁠адресом 172.16.168.0 и маской сети 255.255.248.0. Сколько в этой сети IP⁠-⁠адресов, для которых количество единиц в двоичной записи IP⁠-⁠адреса не кратно 5?`
Тут все просто:
```python
from ipaddress import * # призываем всю библиотеку
net = ip_network(f'172.16.168.0/255.255.248.0', 0) # адрес сети делаем
cnt = 0 # очередной счетчик
for ip in net: 
    s = f'{ip:b}' # делаем, получается, айпишники на основе адреса
    if s.count('1') % 5 != 0: # тут считаются единицы
        cnt += 1
print(cnt)
```
Все! Теперь, главное, синтаксис запомнить надо.


### 14
а можно все не писать? я только важное покажу
Задача на перевод из одной системы счисления в другую
делаем так:(например, шестеричная)
```python
a = 1241489 # рандом число
b = [] # массив который станет числом в шестеричной
while a!=0: # начинаем переводить по алгоритму
	b.append(a%6) # добавляем остаток...
	a//=6 # ... и делим само число на него
b = b[::-1] # число получается перевернутым, поэтому ставим с головы на ноги
''.join(b) # соединяем массив в строку
c = int(b) # иии шлифуем это в обычное число
```
Дальше ориентируйтесь по ситуации, но должно быть все в целом понятно


### 16
Базированнейшая рекурсия
Функция возвращает функцию, что тут непонятного
Пример:
`Алгоритм вычисления значения функции F(n), где n  — натуральное число, задан следующими соотношениями:
`F(n) =  1 при n  =  1;
`F(n)  =  (n − 1) · F(n − 1), если n>1.
`Чему равно значение выражения (F(2024) + 2 · F(2023)) /F(2022)?`
Объявляем функцию:
```python
def eblan(x): # функции без аргуметов (имя_аргумента) не бывают
	if x == 1: # условие задачки
		return 1
	else:
		return ((x-1) * eblan (x-1))
print((eblan(2024) + 2 * eblan(2023)) / eblan(2022))
```
Казалось бы, задачка решена, но нет - она вылезла за предел рекурсии. Нам поможет библиотека sys с подключением всей библиотеки:
```python
from sys import * # подключаем библиотеку

setrecursionlimit(1500) # увеличиваем глубину рекурсии - чем больше, тем лучше, но не переусердствуйте
```
Этот кусочек кода вставляем перед объявлением функции и балдеем с результатов.


### 17
(ух, сложна) Вру, в этой задачке просто куча действий, но все банальные
`В файле содержится последовательность натуральных чисел. Её элементы могут принимать целые значения от 1 до 100 000 включительно. Определите количество пар последовательности, в которых остаток от деления хотя бы одного из элементов на 16 равен минимальному элементу последовательности. В ответе запишите количество найденных пар, затем максимальную из сумм элементов таких пар. В данной задаче под парой подразумевается два идущих подряд элемента последовательности.`
Сразу код с пояснениями:
```python
s = open('17.txt')  
x = 0  # счетчик
b = []  # сюда суммы
a = []  # а сюда циферки нормальные
for f in s:  
    a.append(int(f)) # вменяемый массив интов
for i in range(len(a) - 1):  # а если тройки, то range(len(a)-2)
    if a[i] % 16 == min(a) or a[i + 1] % 16 == min(a):  # условие
        x += 1  
        b.append(a[i] + a[i + 1])  
print(x, max(b))
```
Действительно легкая задача. На самом деле условий может быть больше и они могут быть сложнее, но я верю в читателей этого дока.


### 23
Такая же рекурсия, но с изысками)
`Исполнитель преобразует число на экране. У исполнителя есть две команды, которые обозначены латинскими буквами:
`A.  Вычти 2.
`B.  Найди целую часть от деления на 2.
`Программа для исполнителя  — это последовательность команд.
`Сколько существует программ, для которых при исходном числе 38 результатом является число 2 и при этом траектория вычислений содержит число 16?
```python
def f(a,b): # первый аргумент - исходное число, второй - конечное
	if a == b: # подходящий вариант, мы дошли
		return 1
	elif a < b: # мы перебежали, вариант не подходит
		return 0
	else:
		return f(a-2,b) + f(a//2,b) # здесь ветвимся
print(f(38,16)*f(16,2)) # умножение потому что потому, учите комбинаторику
```
Ничего сложного, правда?


### 24
На удивление, банальная работа со строками, можете хоть в блокноте делать, но покажу питон вариант
`Текстовый файл состоит из цифр 0, 6, 7, 8, 9 и знаков арифметических операций «−» и «*» (вычитание и умножение). Определите максимальное количество символов в непрерывной последовательности, которая является корректным арифметическим выражением с целыми неотрицательными числами. В этом выражении никакие два знака арифметических операций не стоят рядом, в записи чисел отсутствуют незначащие (ведущие) нули и число 0 не имеет знака. В ответе укажите количество символов.
```python
potom...
```


### 25
Маски - библиотека **fnmatch**
`Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
`символ «?» означает ровно одну произвольную цифру;
`символ «*» означает любую последовательность цифр произвольной длины; в том числе может задавать и пустую последовательность.
`_Например,_ маске 123*4?5 соответствуют числа 123405 и 12300405.
`Среди натуральных чисел, не превышающих 10^10, найдите все числа, соответствующие маске 3?12?14*5, делящиеся на 1917 без остатка. В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания, а во втором столбце  — соответствующие им результаты деления этих чисел на 1917.
```python
from fnmatch import fnmatch

for i in range(30120145,3912914995,10): # границы от мин до макс по маске
	if fnmatch(str(i),'3?12?14*5'): # fnmatch сравнивает строки, если что
		if i%1917==0:
			print(i,i//1917)
```
Теперь проведем оптимизацию, ведь 10^10 это чучуть долговато:
```python
for i in range(30121821,3912914995,1917): # нашли ближайшее делящееся на 1917
	if fnmatch(str(i),'3?12?14*5'):
		print(i,i//1917)
```
В первом случае цикл идет с шагом 10, т.к. последний десяток - константа, так что мы о нем не волнуемся. Во втором же случае мы перебираем **все** числа в этом диапазоне, делящиеся на 1917, так что мы а) не беспокоимся об условии делимости б) сокращаем работу цикла в разы.
Ответ получен, шалость удалась

###### Делители - циклы с оптимизацией
`Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку (125 256; 125 330), числа, имеющие ровно шесть различных чётных натуральных делителей. Для каждого найденного числа запишите эти шесть делителей в шесть соседних столбцов на экране с новой строки. Делители в строке должны следовать в порядке возрастания.
```python
for i in range(125256, 125330):
    x = 0 # счетчик для делителей
    dell = [] # массив для маленьких делителей
    delobr = [] # массив для больших делителей
    for j in range(2, int(i ** 0.5) + 1): # оформляем пробег по числу
        if i % j == 0:
	        if j % 2 == 0: # условия задачи
	            x += 1 # считаем делители
	            dell.append(j) # добавляем маленькие делители
	            delobr.append(i // j) # и большие, начинается с наибольшего
	hell_naw = dell+delobr[::-1] # объединяем все в один массив, реверсим большие
	# на деле можно и сортануть потом, но я предпочел просто пройти массив больших делителей наоборот, что в принципе тоже будет работать
    if x == 3:
        print(hell_naw)
```
Мой тейк на эту задачу, но вроде работает
Главное в такой задаче - быть готовым ко всему) Уметь оптимизировать, ставить условия подходящие для задачи - и все в ваших руках