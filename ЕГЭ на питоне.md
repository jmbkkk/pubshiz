## Здесь будут рассмотрены всевозможные решения задач ЕГЭ на python'e
#ЕГЭ #питон 

Ну и перед началом дайте мне вступительное слово, очень хочу немного поболтать. Сейчас тут представлены решения многих задач, однако важно одно понимать всего одно, чтобы решить все задачи на ЕГЭ. Все очень просто. НЕ ЗАУЧИВАЙТЕ КОД.НИ В КОЕМ СЛУЧАЕ. В этом файле перед вами будут куски кода, которые так и манит заучить. НЕТ! Составляя этот файл - цель была научить людей писать ЕГЭ как можно лучше. Каждая (почти) строка кода оснащена комментарием, где написано что эта строка делает в коде. Однако важно учесть, что это все сделано, с тем, что вы имеете хоть какое то понятие о программировании и малейшие знания о питоне. Если вы задаёте вопросы что это за for? зачем тут перед строкой f? В смысле тут цикл внутри массива? Пожалуйста, попробуйте загуглить свой вопрос. А ещё лучше спросить у нейросети. Они точно все расскажет. Рекомендую использовать [Perplexity](https://www.perplexity.ai/)Задайте свой вопрос, добавьте кусочек код и вы получите ответ на ваш вопрос, а так же поднимите свой уровень программирования!  Ну и конечно все задачи взяты с лучшего сайта https://kompege.ru/, обязательно зайдите туда и попробуйте попрактиковаться с задачей, после того, как узнали её решение!

P.S. обязательно узнайте что такое генератор списков в питоне
## Задачи [5](#5), [8](#8), [9](#9), [12](#12), [13](#13), [14](#14), [16](#16), [17](#17), [23](#23), [24](#24), [25](#25), [26](#26), [27](#27)

### 5
Задача подразумевает под собой различную работу с числами, тут мы рассмотрим самый популярный из её вариантов - перевод из  десятичной системы счисления и работу с полученным числом. 
###### Условие
На вход алгоритма подаётся натуральное число _N_. Алгоритм строит по нему новое число _R_ следующим образом.
1.  Строится двоичная запись числа _N_.

2.  К этой записи дописываются справа ещё два разряда по следующему правилу:

а)  складываются все цифры двоичной записи числа _N_, и остаток от деления суммы на 2 дописывается в конец числа (справа). Например, запись 11100 преобразуется в запись 111001;
б)  над этой записью производятся те же действия  — справа дописывается остаток от деления суммы её цифр на 2.

Полученная таким образом запись является двоичной записью искомого числа _R_. Укажите минимальное число _R_, которое превышает число 396. В ответе это число запишите в десятичной системе счисления.

###### Решение
Для начала разберемся с переводом в двоичную запись числа N. Функция перевода **числа** из десятичной системы в двоичную с образованием **строки**:

```python
bin_n = bin(n)[2:]
```
(для перевода в любую систему счисления смотреть [тут](#14))

Далее начинаем перебор N-ок через цикл, а внутри выполняем наше условие. После выполнения условия, проверим подходит ли наша R для ответа
```python
ans = 9999999999 # максимально возможное, чтобы найти минимум
for n in range(1000):
	bin_n += (bin_n.count('1')*1) % 2
	bin_n += (bin_n.count('1')*1) % 2
	R = int(bin_n, 2) # перевод в десятичную из двоичной
	if R > 396:
		ans = min(ans, R) # ищем минимальное R
print(ans)
```
Вуаля! Теперь ищем то, что задано нам задачей и наслаждаемся правильным ответом.

###### Остальные типы задач
Как правило, во всех остальных случаях достаточно перебрать все числа из определённого диапазона (трехзначные - это от 100 до 1000, четырехзначные - это от 1000 до 10000 и т.д.) и проверку различных условий на них. Это можно сделать с помощью как обычного цикла, так и itertools (чуть подробнее [тут](#8) и [тут](https://docs.python.org/3/library/itertools.html))

### 8 - комбинаторика
##### Теория
Эта задача является достаточно простой комбинаторикой. Если вы достаточно хорошо её знаете, то можете решить её руками. Мы будем смотреть решение на питоне, потому что оно удобно и универсально

Задача настраивает нас на работу со вложенными циклами, но есть другой способ: библиотека **[itertools](https://docs.python.org/3/library/itertools.html).** Сама библиотека обширная, но нам понадобится всего два метода из неё: `product` и `permutations`. 
* product - создание всех возможных комбинаций по заданной длине из списка символов
```python
from itertools import *

a = list(product('abc', repeat=4))
for s in a:
	print(s)
# Ожидаемый вывод
# ('a', 'a', 'a', 'a')  
# ('a', 'a', 'a', 'b')  
# ('a', 'a', 'a', 'c')  
# ('a', 'a', 'b', 'a')  
# ('a', 'a', 'b', 'b')  
# ...  
# ('c', 'c', 'c', 'a')  
# ('c', 'c', 'c', 'b')  
# ('c', 'c', 'c', 'c')
```
* permutations - создание всех комбинаций заданной длины из списка символов без повторений этих символов
```python
from itertools import *

a = list(permutations('abcd', r=4))
for s in a:
	print(s)
# Ожидаемый вывод
# ('a', 'b', 'c', 'd')  
# ('a', 'b', 'd', 'c')  
# ('a', 'c', 'b', 'd')  
# ('a', 'c', 'd', 'b')  
# ...  
# ('d', 'b', 'c', 'a')  
# ('d', 'c', 'a', 'b')  
# ('d', 'c', 'b', 'a')
```

Ну и наконец, для решения этой задачи необходимо обладать базовыми знаниями о условиях. Давайте посмотрим на решение такой задачи

##### Первая задача
###### Условие
Определите количество `12-ричных` `шестизначных` чисел, в записи которых содержится ровно `одна` цифра «B» и `равное` количество чётных и нечётных цифр.
###### Решение
Для перебора всех чисел, достаточно просто указать нашу строку со всеми возможными цифрами в 12-ричной СИ
```python
from itertools import *  
  
alphabet = list(range(12)) # 12-значная СИ  
x = 0  # переменная-счетчик  
numbers = list(product(alphabet, repeat=6))  # числа шестизначные  
for number in numbers:  
    if number[0] > 0:  # первая цифра не может быть нулем  
        if number.count(11) == 1:  # только 1 цифра B  
            if sum(digit % 2 for digit in number) == 3: # если число четное, то остаток будет 0, иначе 1  
                # если у нас 6-значное число, то должно быть 3 нечетных                x += 1  
print(x)
```

##### Вторая задача
###### Условие
Сколько существует `шестнадцатеричных` `трёхзначных` чисел, в которых `все цифры различны `и `никакие` две чётные или две нечётные цифры не стоят рядом?
###### Решение
Тут вообще можно написать море условных операторов, но у нас есть генераторы списков, поэтому
```python
from itertools import *  
  
alphabet = '0123456789abcdef' # 16-значная СИ  
chet = '02468ace' # только четные  
ne_chet = '13579bdf' # только не четные  
  
x = 0  # переменная-счетчик  
numbers = list(permutations(alphabet, r=3))  # числа трехзхначные  
bad_options = list(permutations(chet, r=2)) + list(permutations(ne_chet, r=2))  
  
# создадим все плохие варианты (там где четные и нечтные будут парами)  
for number in numbers:  
    if number[0] > '0':  # первая цифра не может быть нулем  
        number = ''.join(number) # перводим список в строку
        if all([''.join(bad_number) not in number for bad_number in bad_options]): # проверяем что плохих комбинаций нет в нашем числе  
            x += 1  
print(x)
```
Стоит обратить внимание, что мы используем ''.join(). Это позволит нам видеть наш список в виде обычной строки. То есть вместо вот этого `('1', '1')` мы получим это  `'11'`
##### Третья задача
###### Условие
Все шестибуквенные слова, в составе которых могут быть только русские буквы Н, О, Р, М, А, Л, Ь, Е записаны в алфавитном порядке и пронумерованы начиная с 1.  
Ниже приведено начало списка  
    1. АААААА  
    2. АААААЕ  
    3. АААААЛ  
    4. АААААМ  
    5. АААААН  
    6. АААААО  
    7. АААААР  
    8. АААААЬ  
Определите сколько слов находится между первым словом начинающимся на «НОРМ» и словом «НЕНОРМ» (не включая эти слова)
###### Решение
Тут говорить нечего, просто запомним индекс слова НЕНОРМ и вычтем из него индекс первого словом начинающимся на «НОРМ»  (и не забудем вычесть единицу, чтобы не учитывать крайние). Заметим, что слова начинающиеся на НОРМ в алфавите будет позже, так что вычитаем из его индекса
Ну и не забываем отсортировать наш алфавит
```python
from itertools import *  
  
alphabet = 'НОРМАЛЬЕ'  # наш алфавит  
alphabet = sorted(alphabet)  # сортируем в алфавитном порядке  
words = product(alphabet, repeat=6)  
  
x = 0  # этим будем бежать по словам  
nenorm_ind = -1  # тут будет наш индекс  
first_norm = -1  
  
for word in words:  
    x += 1  
    word = ''.join(word)  
    if word[:4] == 'НОРМ':  # проверяем начало слова на НОРМ  
        first_norm = x  
        break  
    if word == 'НЕНОРМ':  
        nenorm_ind = x  
  
print(first_norm - nenorm_ind - 1)
```

### 9
Знаю, что многие предпочтут решить задачу в excel, но на питоне решение красивее и, скорее всего, быстрее.
###### Условие
Откройте файл электронной таблицы, содержащей в каждой строке шесть натуральных чисел.
Назовём ячейку таблицы интересной, если выполняются следующие условия:
* число в данной ячейке больше не встречается в данной строке;
* число в данной ячейке встречается в данном столбце, включая данную ячейку, меньше 170 раз.
Определите количество строк таблицы, содержащих не менее 4 интересных ячеек.

###### Решение
Для начала нам понадобится сделать файл перевариваемым для питона - открываем файл в excel, жмем "Сохранить как", находим свою папку с python проектом и сохраняем файл туда **в формате .txt или .csv(разделители - запятые)**. Это определяет разделители текста и его метод переноса, например, в формате .csv разделителями будут являться **точки с запятой(или запятые, тоже проверьте)**, а методом переноса - **\n**.
Выглядит же голая строка в формате .csv так:
`4;3452;25;234\n`
Для работы с числами нам будет необходимо убрать разделители и символ переноса.
Кстати, далее будет код для .csv, поэтому рекомендую самим проверить символы разделения и переноса для .txt - слева от области кода в PyCharm можно увидеть ваши файлы в папке, а оттуда они тащатся на область справа от вашего main.py
```python
s = open('название файла.расширение файла')
qwerty = 0 # переменная-счетчик, в большинстве задач нужно
# но могут попасться задачи типа "найдите максимальную сумму", поэтому можно завести сюда пустой массив b = [] и в него методом b.append(ваше_значение) вводить все суммы, а потом вывести max(b)
arow = [[int(x) for x in s.split(';')] for f in s] # создаем массив из строк нашего файла  
acol = [[arow[i][j] for i in range(len(arow))] for j in range(N)] # создаем массив из колонок нашего файла (N - это кол-во колонок в файле)
  
for i in range(len(arow)): # arow[i] - это текущая строка  
	... # тут пишем все наши условия задачи
for j in range(len(acol)): # acol[i] - это текущая колонка
    ... # тут пишем все наши условия задачи
	
```
Тут, в строке с объявлением arow и acol, были использованы более простые методы заполнения массива; но это все равно будет считаться циклом, просто в упрощенном виде (для тех, кому очень важно время выполнения программы).

Теперь к решению задачи:
* число в данной ячейке больше не встречается в данной строке;
* число в данной ячейке встречается в данном столбце, включая данную ячейку, меньше 170 раз.
```python
...
for i in range(len(arow)): # идем по всей таблице  
    kint = 0 # кол-во интересных клеток в сторке  
    for j in range(6): # идем по всей сторе, и ищем интересные ячейки  
        x = arow[i][j] # заведем x, чтобы бло проще  
        if arow[i].count(x) == 1 and acol[j].count(x) < 170: # проверка условий  
            kint += 1  
    if kint >= 4:  
        k += 1  
print(k)
```

### 12
Одна из самых легких задачек на работу со строками. В ней нужен всего один метод - *.replace*
###### Условие
Исполнитель Редактор получает на вход строку цифр и преобразует её. Редактор может выполнять две команды, в обеих командах _v_ и _w_ обозначают цепочки цифр.
А)  **заменить** (_v_, _w_).
Эта команда заменяет в строке первое слева вхождение цепочки _v_ на цепочку _w_. Например, выполнение команды **заменить** (2222, 52) преобразует строку 05222250 в строку 055250.
Если в строке нет вхождений цепочки _v_, то выполнение команды **заменить** (_v_, _w_) не меняет эту строку.

Б)  **нашлось** (_v_).
Эта команда проверяет, встречается ли цепочка _v_ в строке исполнителя Редактор. Если она встречается, то команда возвращает логическое значение «истина», в противном случае возвращает значение «ложь». Строка исполнителя при этом не изменяется.

###### Решение
Для начала - списываем весь код из задачи вам в питон(я верю, это легко). 
Затем смотрим, какая строка нам дана. В примере - строка **а** состоит из 69 цифр "2".
```python
a = '2'*69 # заводим строку
while '2222' in a or '55' in a: # это типа мы списали код из задачи
	if '2222' in a: # значения придуманы с ходу, прога зациклится скорее всего
		a = a.replace('2222','52',1) # применяем наш метод replace
	else:
		a = a.replace('55','25',1)
print(a)
```
Метод replace заменяет первый аргумент в строке на второй.
###### Примечание: 
Метод replace, описанный мной выше в 9 задаче, имел всего 2 аргумента, здесь же их 3. Разница? В этой задаче метод используется всего 1 раз за итерацию цикла, поэтому и третий аргумент - 1. В 9 задаче нам нужно избавиться от всех '\n' , а пустой аргумент в replace заменяет все найденные элементы единовременно.


### 13

Задача достаточно простая. Главное что надо знать: 
* первый и последний адрес узла в каждой сети зарезервированы и не могут использованы компьютерами
* маска состоит из единиц, за которыми идут нули, а всего в маске 32 символа
* каждая "часть" адреса или маски - это байт
* байт может принимать значение от 0 до 255 в десятеричной СИ
* в байте всегда 8 цифр, в двоичной записи. Если их недостаточно, то в начало приписываются нули

На самом деле все что нам надо - это маска сети, а так же адрес узла или адрес сети. А если их нет, то всегда можно использовать цикл с перебором.
Разберем, как решать эту задачу, если у нас уже дана маска и что-то из этого
###### Условие
Сеть задана IP⁠-⁠адресом **172.16.168.0** и маской сети **255.255.248.0**. Сколько в этой сети IP⁠-⁠адресов, для которых количество единиц в двоичной записи IP⁠-⁠адреса не кратно **5**?

###### Решение
В питоне даже для такой задачи есть библиотека. Называется она просто: **ipaddress**.
Тут все просто:
```python
from ipaddress import * # призываем всю библиотеку
net = ip_network('172.16.168.0/255.255.248.0', 0) # адрес сети делаем
cnt = 0 # счетчик
for ip in net:
    s = bin(int(ip))[2:].zfill(32) # делаем двоичную запись адресса
    if s.count('1') % 5 != 0: # тут считаются единицы
        cnt += 1
print(cnt)
```
Аналогичное решение, будет если будет дан узел сети.
От `net` мы можем получить:
* маску сети - `net.netmask`
* адрес сети - `net.network_address`
* ВСЕ ip адреса в этой сети - цикл, как в нашей задаче. НО ВНИМАНИЕ! Первый адрес будет адресом сети (его не может иметь компьютер), а так же последним будет зарезервирован под широковещательный (его тоже не может иметь компьютер)
* ip адреса, которые могут иметь КОМПЬЮТЕРЫ - цикл, как в задаче, но через `net.hosts()`
* кол-во ip адресов `len(lins(net))`

###### Проблема, задача без маски

И так, переходим к главной боли этой задаче: задачи без маски. На самом деле - задача все ещё супер простая. Мы можем перебрать маску через числа от 0 до 32. Это можно сделать, поскольку маска выражена исключительно единицами, после которой идут нули, пока цифр в маске не станет 32. Давайте решим такую задачу

###### Условие
Для узла с IP-адресом `218.48.192.56` адрес сети равен `218.48.192.0`. Сколько существует различных возможных значений третьего слева байта маски, если известно, что в этой сети не менее 500 узлов?

###### Решение
```python
from ipaddress import *
for m in range(0,33): # перебор масок
	net = ip_network(f'218.48.192.56/{m}', 0) # составим сеть, по нашему ip
	if str(net.network_address) == '218.48.192.0': # проверяем, что используем нуженую сеть
		if len(lins(net.hosts())) > 500: # условие задачи
			print(net.netmask) # получим все маски, что подходят условию

```

### 14
Для этой задачи множество вариантов, такие как уравнения, просто выражения, перебор. Однако все они объединены одним - работой с системами счисления.
###### Перевод систем счисления
делаем так:(например, шестеричная)
```python
a = 1241489 # рандом число
b = [] # массив который станет числом в шестеричной
while a!=0: # начинаем переводить по алгоритму
	b.append(a%6) # добавляем остаток...
	a//=6 # ... и делим само число на него
b = b[::-1] # число получается перевернутым, поэтому ставим с головы на ноги
''.join(b) # соединяем массив в строку
c = int(b) # иии шлифуем это в обычное число
```
###### Решение
В случае с уравнением, просто запускаем перебор иксов в циклах, пока не найдем нужный ответ
```python
for x in range(n): # тут n система счисления для числа, в котром есть x
 a = ... # приводим в нужную нам систему
 b = ... # аналогично делаем с b
 if (a+b) % 19 == 0: # представим, что в задаче нужно найти x, для которого выражение делится на 19
	 print(x)
```
Остальные случаи зачастую даже легче, так что предлагаю их разобрать самим :)


### 16
Базированнейшая рекурсия. Функция возвращает функцию, что тут непонятного
###### Условие
Алгоритм вычисления значения функции F(n), где n  — натуральное число, задан следующими соотношениями:
`F(n) =  1 при n  =  1;
`F(n)  =  (n − 1) · F(n − 1), если n>1.
Чему равно значение выражения (F(2024) + 2 · F(2023)) /F(2022)?

###### Решение
Запишем функцию из условия:
```python
def F(x): # объявляем функцию
	if x == 1: # условие задачки
		return 1
	else:
		return ((x-1) * F (x-1))
print((F(2024) + 2 * F(2023)) / F(2022))
```
Казалось бы, задачка решена, но нет - она вылезла за предел рекурсии. Нам поможет библиотека **sys** с подключением всей библиотеки:
```python
from sys import * # подключаем библиотеку

setrecursionlimit(9999999) # увеличиваем глубину рекурсии - чем больше, тем лучше, но не переусердствуйте
```
Этот кусочек кода вставляем перед объявлением функции и балдеем с результатов.

Задача вновь решена! Хоть бы не так! Не забываем, что мы пишем ЕГЭ, а это значит, что комп нам скорее всего достанется не лучший, а именно: который от увеличения лимита рекусрсии вскипит как чайник и уйдет в закат. Давайте делать проще. Будем запоминать значения прошлых вызовов и нам не придется бегать постоянно. На самом деле даже писать ничего не придется. Просто используем библиотеку `functools`
```python
from functools import lru_cache # подключаем библиотеку

@lru_cache(None) # говорим, что будем запоминать значения этой функции
def F(x): 
	if x == 1: # условие задачки
		return 1
	else:
		return ((x-1) * F (x-1))

for x in range(1, 2025):
	f(n) # заполним наш кэш, чтобы потом это все не считать

print((F(2024) + 2 * F(2023)) / F(2022))
```
Вот и все! Теперь задача решена на 99,9%. Если будет более 1 функции, то `@lru_cache(None)` надо ставить перед объявлением каждой из функций.
### 17
(ух, сложна) Вру, в этой задачке просто куча действий, но все банальные
###### Условие
В файле содержится последовательность натуральных чисел. Её элементы могут принимать целые значения от 1 до 100 000 включительно. Определите количество пар последовательности, в которых остаток от деления хотя бы одного из элементов на 365  равен минимальному двузначному элементу последовательности. В ответе запишите количество найденных пар, затем максимальную из сумм элементов таких пар. В данной задаче под парой подразумевается два идущих подряд элемента последовательности.
###### Решение

```python
s = open('17.txt')  
x = 0  # счетчик
b = []  # сюда суммы
a = []  # а сюда циферки нормальные
mn_a = float('inf') # тут будем считать минимальный двузначный элемент. 
# Можете загуглить поиск минимального элемента в массиве, если не понятно, почему float('inf')
for f in s:  
	number = int(f)
    a.append(number) # вменяемый массив интов
    if 9 < number < 100: # проверка, что число подходит под определение из задачи
	    mn_a = min(mn_a, number)

for i in range(len(a) - 1): # не выодим за пределы массива (с тройками -2 и тд)
    if a[i] % 365 == mn_a or a[i + 1] % 365 == mn_a:  # условие
        x += 1  
        b.append(a[i] + a[i + 1])  
print(x, max(b))
```
Действительно легкая задача. На самом деле условий может быть больше и они могут быть сложнее. Обычно в таких задачах предлагают дополнительную работу с числами, такую как возведение в квадрат, различные арифметические операции, взятие модуля, последние цифры в числе и тд., но это базовые операции, если вы поймали, что не знаете как это делать, то попробуйте посмотреть подробные вебы или поискать инфу в интернете!

### 23
Такая же рекурсия, что в 16, но с изысками)
###### Условие
Исполнитель преобразует число на экране. У исполнителя есть две команды, которые обозначены латинскими буквами:
**A.**  `Вычти 2`
**B.** `Найди целую часть от деления на 2.`
Программа для исполнителя  — это последовательность команд.
Сколько существует программ, для которых при исходном числе `38` результатом является число `2` и при этом траектория вычислений содержит число `16`, но не содержит `20`?
###### Решение

```python
def f(a,b): # первый аргумент - исходное число, второй - конечное
	if a == 20:
		return 0 # 20 - запретное число, в нашей задаче
	if a == b: # подходящий вариант, мы дошли
		return 1
	elif a < b: # мы перебежали, вариант не подходит
		return 0
	else:
		return f(a-2,b) + f(a//2,b) # здесь ветвимся
print(f(38,16)*f(16,2)) # умножение потому что потому, учите комбинаторику
```
Ничего сложного, правда?
### 24
На удивление, банальная работа со строками, можете хоть в блокноте делать, но покажу питон вариант
###### Условие
Текстовый файл состоит из цифр 0, 6, 7, 8, 9 и знаков арифметических операций «`−`» и «`*`» (вычитание и умножение). Определите максимальное количество символов в непрерывной последовательности, которая является корректным арифметическим выражением с целыми неотрицательными числами. В этом выражении никакие два знака арифметических операций не стоят рядом, в записи чисел отсутствуют незначащие (ведущие) нули и число 0 не имеет знака. В ответе укажите количество символов.

###### Решение
```python
potom...
```

### 25
Для решения этой задачи можно использовать легкий и сложный способы, тут будет показан легкий, однако от сложного он отличается только библиотекой
###### Условие
Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
символ «`?`» означает ровно одну произвольную цифру;
символ «`*`» означает любую последовательность цифр произвольной длины; в том числе может задавать и пустую последовательность.
Например, маске `123*4?5` соответствуют числа `123405` и `12300405`.
Среди натуральных чисел, не превышающих 10^10, найдите все числа, соответствующие маске `3?12?14*5`, делящиеся на `1917` без остатка. В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания, а во втором столбце  — соответствующие им результаты деления этих чисел на `1917`
###### Решение
```python
from fnmatch import fnmatch

for i in range(30120145,3912914995,10): # границы от мин до макс по маске
	if fnmatch(str(i),'3?12?14*5'): # fnmatch сравнивает строки, если что
		if i%1917==0:
			print(i,i//1917)
```
Теперь проведем оптимизацию, ведь 10^10 это чучуть долговато:
```python
for i in range(30121821,3912914995,1917): # нашли ближайшее делящееся на 1917
	if fnmatch(str(i),'3?12?14*5'):
		print(i,i//1917)
```
В первом случае цикл идет с шагом 10, т.к. последний десяток - константа, так что мы о нем не волнуемся. Во втором же случае мы перебираем **все** числа в этом диапазоне, делящиеся на 1917, так что мы а) не беспокоимся об условии делимости б) сокращаем работу цикла в разы.
Ответ получен, шалость удалась

###### Делители - циклы с оптимизацией
Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку (125 256; 125 330), числа, имеющие ровно шесть различных чётных натуральных делителей. Для каждого найденного числа запишите эти шесть делителей в шесть соседних столбцов на экране с новой строки. Делители в строке должны следовать в порядке возрастания.
```python
for i in range(125256, 125330):
    x = 0 # счетчик для делителей
    dell = [] # массив для маленьких делителей
    delobr = [] # массив для больших делителей
    for j in range(2, int(i ** 0.5) + 1): # оформляем пробег по числу
        if i % j == 0:
	        if j % 2 == 0: # условия задачи
	            x += 1 # считаем делители
	            dell.append(j) # добавляем маленькие делители
	            delobr.append(i // j) # и большие, начинается с наибольшего
	hell_naw = dell+delobr[::-1] # объединяем все в один массив, реверсим большие
	# на деле можно и сортануть потом, но я предпочел просто пройти массив больших делителей наоборот, что в принципе тоже будет работать
    if x == 3:
        print(hell_naw)
```
Мой тейк на этыыу задачу, но вроде работает. Главное в такой задаче - быть готовым ко всему. Уметь оптимизировать, ставить условия подходящие для задачи - и все в ваших руках

###### Сложный способ
Зачем решать сложным способом? Да потому что он работает гораздо быстрее и не нужно проводить кучу оптимизаций. Для его исполнения можно использовать регулярные выражения. Подробнее [тут](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Regular_expressions)
### 27
В 25 году обещают кластеризацию, так что давайте делать грязь.
Ну, во первых давайте не будем пугаться этого страшнейшего условия и разберем все по полочкам. Нам дан список из звезд, которые в свою очередь состоят в разных кластерах. Наша задача найти  центры каждого кластера, а дальше уже что то там выводить, можно будет разобраться в конце. 

###### Условие
 В рамках международной программы “Галактический AI”, учёные используют суперкомпьютеры и современные алгоритмы машинного обучения для анализа звёздных систем. Задача программы — определить центры кластеров звёзд, чтобы улучшить космическую навигацию для спутников и создать точные карты галактик. Кластер звёзд – это набор звёзд (точек) на графике, лежащий внутри круга. Каждая звезда обязательно принадлежит только одному из кластеров.

Истинный центр кластера, или центроид, – это одна из звёзд на графике, сумма расстояний от которой до всех остальных звёзд кластера минимальна.

Под расстоянием понимается расстояние Евклида между двумя точками _A(x1,y1)A(x1​,y1​)_ и B(x2,y2)B(x2​,y2​) на плоскости, которое вычисляется по формуле: 
d(A,B) = $\sqrt{x_2−x_1)^2+(y_2−y_1)^2}$

**Аномалиями** назовём звёзды, находящиеся на расстоянии более одной условной единицы от звёзд кластеров. При расчётах аномалии учитывать не нужно.

В файле A хранятся данные о звёздах двух кластеров. В каждой строке записана информация о расположении на карте одной звезды: сначала координата xx, затем координата yy. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.

В файле B хранятся данные о звёздах четырёх кластеров. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А.

Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: PxPx​ – среднее арифметическое абсцисс центров кластеров, и PyPy​ – среднее арифметическое ординат центров кластеров.

В ответе запишите четыре числа: в первой строке сначала целую часть произведения Px×10000Px​×10000, затем целую часть произведения Py×10000Py​×10000 для файла А, во второй строке – аналогичные данные для файла B.

###### Решение

Замечу, что поскольку решение не общего вида, то для каждых задач, числа будут разные, обязательно внимательно прочитайте решение и максимально вникните в него. Ну и читать эту задачу без файла будет достаточно сложно, так что заходим на [КЕГЭ](https://kompege.ru/task) , вбиваем номер 19715 и скачиваем фалы.

Давайте поймем, что по факту в файле A у нас 2 кластера, а в файле B их три. В первую очередь, надо выполнить первую задачу - деление звезд по кластерам. Давайте сделаем все легко, и, вы не поверите, но откроем exel и посмотрим как выглядят наши кластеры. 

Быстрый гайд как: 
* Открываем exel файл
* выделяем столбцы
* сверху ищем вкладку вставка
* там поле диаграммы 
* ищем глазками диаграмму, которая выглядит как система координат с точками,
* создаем её. 

Тут надо заметить, что скорее всего у вас диаграмма будет в каком то другом размере, к примеру с единичным отрезком в 2 или даже 5. Это надо исправить. Для этого двойной клик ЛКМ по оси, далее находим формат оси и в настройке основные деления выставляем 1. Это следует сделать с обоими осями. 

В итоге у нас получиться тот самый график, про который идет речь в задании. Теперь перед нами стоит задача, разделить все кластеры, а так же выявить аномалии. Это все очень просто, давайте для начала поделим эти кластеры с помощью прямой (чем проще, тем лучше), в большинстве задач поделить можно на прямую y = CONST или x = CONST. Затем, аналогично проделаем для аномалий, чтобы знать как их убрать. В данной задаче, я получил, что нам подходит прямая `x=13`, а чтобы разделить кластеры и аномалии, можно заметить, что первый кластер находиться в промежутке y от -1 до 13, а второй от 3 до 18, только вот и аномалии входят в это число, так что для них отдельно выписываем x и y, чтобы в коде отделить их от кластеров. Так, если точки от 14 до 16 по x и от 3 до 5 по y, а так же более 28 по x мы просто будем игнорировать. И так, пишем код.

```python
clustaerA = [[], []] # в каждый массив будем закидывать координаты, которые относятся к опрделенному кластеру
for line in open('27_A.txt'):
	x, y = [float(k) in line.split()] # делим нашу строку на список координат
	if x > 13: # рассмотрим первый кластер
		if -1 < y < 13: # исключим аномалии первого кластера
			clustaerA[0].append([x, y]) # все норм, запишем
	elif x < 13: # рассмотрим второй кластер
		if 14 < x < 16 and 3 < y < 5: # не включаем аномалию
			pass # пропускаем этот шаг цикла, делать тут больше нечего
		elif x < 28: # исключим аномалии второго кластера
			clustaerA[1].append([x, y]) # все верифнули, координаты те
	
```

Ура, кластеризация завершена.  Для кластеров из файла B будет аналогично, но вот только в clustaerB будет уже 3 массива, поскольку кластеров в этом файле тоже 3.

Soon-soon